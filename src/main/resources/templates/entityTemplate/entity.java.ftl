package [=PackageName].domain.model;

import java.io.Serializable;

import javax.persistence.*;
import java.util.HashSet;
import java.util.Set;
import java.util.Date;
<#if ClassName == AuthenticationTable>
<#if AuthenticationType == "database" || (AuthenticationType != "database" && (UsersOnly?? && UsersOnly == "true"))>
import [=PackageName].domain.model.[=AuthenticationTable]permissionEntity;
import [=PackageName].domain.model.[=AuthenticationTable]roleEntity;
</#if>
</#if>
@Entity
@Table(<#if TableName??>name = "[=TableName]",</#if> schema = "[=SchemaName]")
<#list CompositeKeyClasses as compositeClass>
<#if ClassName == compositeClass>
@IdClass([=IdClass].class)
</#if>
</#list>
public class [=ClassName]Entity implements Serializable {

<#list Fields as key,value>
 <#if value.fieldType?lower_case == "long">
  private Long [=value.fieldName];
 <#elseif value.fieldType?lower_case == "integer" >
  private Integer [=value.fieldName];
 <#elseif value.fieldType?lower_case == "short" >
  private Short [=value.fieldName];
 <#elseif value.fieldType?lower_case == "double" >
  private Double [=value.fieldName];
 <#elseif value.fieldType?lower_case == "boolean">
  private Boolean [=value.fieldName];
 <#elseif value.fieldType?lower_case == "date">
  private Date [=value.fieldName];
 <#elseif value.fieldType?lower_case == "string">
  private String [=value.fieldName];
 </#if> 
</#list>
 
  public [=ClassName]Entity() {
  }

<#list Fields as key,value>
 <#if value.fieldType?lower_case == "long">
  <#if value.isPrimaryKey!false>
  @Id
  <#if value.isAutogenerated!false>
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  </#if>
  <#else>
  @Basic
  </#if>
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')])
  public Long get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](Long [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  }
  
 <#elseif value.fieldType?lower_case == "integer">
  <#if value.isPrimaryKey!false>
  @Id
  <#else>
  @Basic
  </#if>
  <#if value.isAutogenerated!false>
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  </#if>
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')])
  public Integer get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](Integer [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  } 
  
  <#elseif value.fieldType?lower_case == "short">
  <#if value.isPrimaryKey!false>
  @Id
  <#if value.isAutogenerated!false>
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  </#if>
  <#else>
  @Basic
  </#if>
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')])
  public Short get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](Short [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  } 
  
  <#elseif value.fieldType?lower_case == "double">
  <#if value.isPrimaryKey!false>
  @Id
  <#else>
  @Basic
  </#if>
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')])
  public Double get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](Double [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  } 
  
 <#elseif value.fieldType?lower_case == "boolean">
  @Basic
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')])
  public Boolean get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](Boolean [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  }
  
 <#elseif value.fieldType?lower_case == "date">
  @Basic
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')])
  public Date get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](Date [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  }
  
 <#elseif value.fieldType?lower_case == "string">
  <#if value.isPrimaryKey!false> 
  @Id
  <#else>
  @Basic
  </#if>
  @Column(name = "[=key]", nullable = [=value.isNullable?string('true','false')], length =<#if value.length !=0>[=value.length?c]<#else>255</#if>)
  public String get[=value.fieldName?cap_first]() {
  return [=value.fieldName];
  }

  public void set[=value.fieldName?cap_first](String [=value.fieldName]){
  this.[=value.fieldName] = [=value.fieldName];
  }
  
 <#else>
  <#list Relationship as relationKey, relationValue>
  <#if value.fieldType == relationValue.eName>
  <#if relationValue.relation == "ManyToOne">
  <#assign i=relationValue.joinDetails?size>
  <#if i==1>
  <#list relationValue.joinDetails as joinDetails>
  <#if joinDetails.joinEntityName == relationValue.eName>
  <#if joinDetails.joinColumn??>
  @ManyToOne
  @JoinColumn(name = "[=joinDetails.joinColumn]"<#if CompositeKeyClasses?seq_contains(ClassName)>, insertable=false, updatable=false</#if>)
  public [=relationValue.eName]Entity get[=relationValue.eName]() {
    return [=relationValue.fName];
  }
  public void set[=relationValue.eName]([=relationValue.eName]Entity [=relationValue.fName]) {
    this.[=relationValue.fName] = [=relationValue.fName];
  }
  
  private [=relationValue.eName]Entity [=relationValue.fName];
  </#if>
  </#if>
  <#break>
  </#list>
 
  <#else>
  
  @ManyToOne(fetch=FetchType.LAZY, cascade=CascadeType.MERGE)
  @JoinColumns({<#list relationValue.joinDetails as joinDetails><#if joinDetails_has_next>@JoinColumn(name="[=joinDetails.joinColumn]"<#if joinDetails.joinColumnType?lower_case !="string">, columnDefinition="[=joinDetails.joinColumnType]"</#if>, referencedColumnName="[=joinDetails.referenceColumn]"<#if CompositeKeyClasses?seq_contains(ClassName)>, insertable=false, updatable=false</#if>),<#else>@JoinColumn(name="[=joinDetails.joinColumn]"<#if joinDetails.joinColumnType?lower_case !="string">, columnDefinition="[=joinDetails.joinColumnType]"</#if>, referencedColumnName="[=joinDetails.referenceColumn]"<#if CompositeKeyClasses?seq_contains(ClassName)>, insertable=false, updatable=false</#if>)</#if></#list>})
  public [=relationValue.eName]Entity get[=relationValue.eName]() {
    return [=relationValue.fName];
  }
  public void set[=relationValue.eName]([=relationValue.eName]Entity [=relationValue.fName]) {
    this.[=relationValue.fName] = [=relationValue.fName];
  }
  
  private [=relationValue.eName]Entity [=relationValue.fName];
  </#if>
  </#if>
  <#if relationValue.relation == "OneToMany">   
  <#list relationValue.joinDetails as joinDetails>
  @OneToMany(mappedBy = "[=ClassName?uncap_first]", cascade = CascadeType.ALL, orphanRemoval = true) 
  public Set<[=relationValue.eName]Entity> get[=relationValue.eName]Set() { 
      return [=relationValue.fName]Set; 
  } 
 
  public void set[=relationValue.eName]Set(Set<[=relationValue.eName]Entity> [=relationValue.fName]) { 
      this.[=relationValue.fName]Set = [=relationValue.fName]; 
  } 
 
  private Set<[=relationValue.eName]Entity> [=relationValue.fName]Set = new HashSet<[=relationValue.eName]Entity>(); 
  <#break>
  </#list>
  </#if>
  <#if relationValue.relation == "OneToOne">
  <#assign i=relationValue.joinDetails?size>
  <#if i==1>
  <#list relationValue.joinDetails as joinDetails>
  <#if joinDetails.joinEntityName == relationValue.eName>
  <#if relationValue.isParent== false>
  <#if joinDetails.joinColumn??>
  
  @OneToOne
  @JoinColumn(name = "[=joinDetails.joinColumn]"<#if CompositeKeyClasses?seq_contains(ClassName)>, insertable=false, updatable=false</#if>)
  public [=relationValue.eName]Entity get[=relationValue.eName]() {
    return [=relationValue.fName];
  }
  public void set[=relationValue.eName]([=relationValue.eName]Entity [=relationValue.fName]) {
    this.[=relationValue.fName] = [=relationValue.fName];
  }
  
  private [=relationValue.eName]Entity [=relationValue.fName];
  </#if>
  </#if>
  </#if>
  <#break>
  </#list>
  <#else>
  <#if relationValue.isParent== false>
  
  @OneToOne(fetch=FetchType.LAZY, cascade=CascadeType.MERGE)
  @JoinColumns({<#list relationValue.joinDetails as joinDetails><#if joinDetails_has_next>@JoinColumn(name="[=joinDetails.joinColumn]"<#if joinDetails.joinColumnType?lower_case !="string">, columnDefinition="[=joinDetails.joinColumnType]"</#if>, referencedColumnName="[=joinDetails.referenceColumn]"<#if CompositeKeyClasses?seq_contains(ClassName)>, insertable=false, updatable=false</#if>),<#else>@JoinColumn(name="[=joinDetails.joinColumn]"<#if joinDetails.joinColumnType?lower_case !="string">, columnDefinition="[=joinDetails.joinColumnType]"</#if>, referencedColumnName="[=joinDetails.referenceColumn]"<#if CompositeKeyClasses?seq_contains(ClassName)>, insertable=false, updatable=false</#if>)</#if></#list>})
  public [=relationValue.eName]Entity get[=relationValue.eName]() {
    return [=relationValue.fName];
  }
  public void set[=relationValue.eName]([=relationValue.eName]Entity [=relationValue.fName]) {
    this.[=relationValue.fName] = [=relationValue.fName];
  }
  
  private [=relationValue.eName]Entity [=relationValue.fName];
  </#if>
  </#if>
  <#if relationValue.isParent== true>
  <#list relationValue.joinDetails as joinDetails>
  
  @OneToOne(mappedBy = "[=ClassName?uncap_first]")
  public [=relationValue.eName]Entity get[=relationValue.eName]() {
    return [=relationValue.fName];
  }
  public void set[=relationValue.eName]([=relationValue.eName]Entity [=relationValue.fName]) {
    this.[=relationValue.fName] = [=relationValue.fName];
  }
  
  private [=relationValue.eName]Entity [=relationValue.fName];
  <#break>
  </#list>
  </#if>
  </#if>
  </#if>
  </#list>
 </#if> 
</#list>

<#if ClassName == AuthenticationTable>
<#if AuthenticationType == "database" || (AuthenticationType != "database" && (UsersOnly?? && UsersOnly == "true"))>
  @OneToMany(mappedBy = "[=AuthenticationTable?uncap_first]", cascade = CascadeType.ALL, orphanRemoval = true) 
  public Set<[=AuthenticationTable]permissionEntity> get[=AuthenticationTable]permissionSet() { 
	return [=AuthenticationTable?uncap_first]permissionSet; 
  } 
 
  public void set[=AuthenticationTable]permissionSet(Set<[=AuthenticationTable]permissionEntity> [=AuthenticationTable?uncap_first]permission) { 
    this.[=AuthenticationTable?uncap_first]permissionSet = [=AuthenticationTable?uncap_first]permission; 
  } 
 
  private Set<[=AuthenticationTable]permissionEntity> [=AuthenticationTable?uncap_first]permissionSet = new HashSet<[=AuthenticationTable]permissionEntity>();

  @OneToMany(mappedBy = "[=AuthenticationTable?uncap_first]", cascade = CascadeType.ALL, orphanRemoval = true) 
    public Set<[=AuthenticationTable]roleEntity> get[=AuthenticationTable]roleSet() { 
      return [=AuthenticationTable?uncap_first]roleSet; 
    } 
 
    public void set[=AuthenticationTable]roleSet(Set<[=AuthenticationTable]roleEntity> [=AuthenticationTable?uncap_first]role) { 
      this.[=AuthenticationTable?uncap_first]roleSet = [=AuthenticationTable?uncap_first]role; 
    } 
 
    private Set<[=AuthenticationTable]roleEntity> [=AuthenticationTable?uncap_first]roleSet = new HashSet<[=AuthenticationTable]roleEntity>(); 
</#if>
</#if>
//  @Override
//  public boolean equals(Object o) {
//    if (this == o) return true;
//      if (!(o instanceof [=ClassName]Entity)) return false;
//        [=ClassName]Entity [=ClassName?lower_case] = ([=ClassName]Entity) o;
//        return id != null && id.equals([=ClassName?lower_case].id);
//  }

}

  
      


